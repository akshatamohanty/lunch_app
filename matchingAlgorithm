function runAlgoOnPool(){
    while(userPool.length > 0){

          //always at index 0 - because the first user is always removed; remove the first user
          var currUser = userPool.splice(0, 1);

          // create a pool for second mate - which should be a close person to the current user
          var pairMatePool = regroup( userPool, currUser );
          var pairMatePool = pairMatePool[0].concat(pairMatePool[1]).concat(pairMatePool [2]); // ordered by priority

          // if pairMatePool.length == 0 - no pair available - can't do anything - user has already been removed from the pool
          if(pairMatePool.length == 0)
            continue;

          // picks the first mate in the given pool with compatible cuisine - or just picks the first person
          var pairMate = pickNextMate( pairMatePool, currUser, false );
          
          // this will happen when no user can be selected such that a third user can be selected -
          // in this case, better to discard the first user and continue
          if(pairMate == undefined)
            continue;

          // this regrouping will give users compatible with both the selected users
          // pairMatePool has to be reordered according to new user
          // ordering of the pool is done to keep compatible people first
          var thirdMatePool = regroup( pairMatePool, pairMate );
          var thirdMatePool = thirdMatePool[2].concat(thirdMatePool[1]).concat(thirdMatePool[0]);

          // pick a third person compatible with the second person - and matching his cuisine
          // if no user with matching cuisine is found, pick first person who gives next pool length > 0
          var thirdMate = pickNextMate( thirdMatePool, pairMate, false );

          // this happens when no third user can give the next pool greater than 0 
          // in this case, switch off pool length condition - pick a person with compatible cuisine
          if(thirdMate == undefined){
            thirdMate = pickNextMate( thirdMatePool, pairMate, true );
            // create match of three people
            addMatch( [currUser, pairMate, thirdMate] );
            // remove the three people from the userpool
            removeFromPool( userPool, [currUser, pairMate, thirdMate]  )
            continue;
          }

          // third mate pool is acceptable to both first and second user - fourth mate pool removes
          // blocked users for third mate also - ordered with best friend for third mate first
          var fourthMatePool = regroup( thirdMatePool, thirdMate );
          var fourthMatePool = fourthMatePool[0].concat(fourthMatePool[1]).concat(fourthMatePool[2]);
          var fourthMate = pickNextMate( fourthMatePool, thirdMate, true );  // switch off next pool length

          // make match of four people
          addMatch( [currUser, pairMate, thirdMate, fourthMate] );
          // remove the four people from the user pool
          removeFromPool( userPool, [currUser, pairMate, thirdMate, fourthMate]  )

                    
    } //while end

    // takes in two users 
    // returns true if either of the users have blocked each other
    // returns false if none of the users have blocked each other
    function userMutualBlock( user1, user2 ){
      // check if user1.id is present in user2 block list
      if( user2.blocked.indexOf(user1._id) > -1 ||  user1.blocked.indexOf(user2._id) > -1 )
        return true;
      
      return false; 
    }

    // returns the connection between two users
    // in 0, 1, 2 form
    function userMutualFriends( user1, user2){
      // check if user1.id is present in user2 block list
      return (user2.known.indexOf(user1._id)>-1) + (user1.known.indexOf(user2._id)>-1) +0; 
    }

    // returns true if the users have atleast one common cuisine
    // later -> or equivalent cuisine - can find restaurant serving atleast one of each
    function userCuisineCompatible( user1, user2 ){
        
        var returnValue = false;

        Restaurant.find({
          cuisine: { $in : user1.cuisine.concat(user2.cuisine) }
        }, function(err, restaurant){
           if(err) console.log(err);

           else returnValue = true;
        })

        return returnValue;
    }


    // takes in a user pool and a current user - divides the group into three layers 
    // length - returns only length of the compatible pool
    // returns a divided pool of all unblocked users for the given current user
    function regroup( userPool, currUser, length ){
        
        var oneWayPool = [];
        var twoWayPool = [];
        var compatible = [];

        for(var i=0; i<userPool.length; i++){
            // if either of the people have blocked, skip the user
            if( userMutualBlock( currUser, userPool[i] ))
              continue;

            // categorize according to compatibility
            switch( userMutualFriends( currUser, userPool[i] ) ) {
                case 0:
                    compatible.push( userPool[i] )
                    break;
                case 1:
                    oneWayPool.push( userPool[i] )
                    break;
                case 2:
                    twoWayPool.push( userPool[i] )
            } // switch end
        } // for-compatibility end

        if(length)
          return [twoWayPool, oneWayPool, compatible]
        else
          return twoWayPool.length + oneWayPool.length + compatible.length;
    }


    // takes a pool and a current user and finds person from the pool with which the given user is cuisine compatible
    // and compatible pool for both these users has length more than 1
    // incase of no cuisine compatibility - the first user or user with next compatible pool length > 1 is selected
    // and returned
    // the matePool is ordered accordin to priority - two way first or compatible first etc
    function pickNextMate(  matePool, currUser, poolLengthOFF  ){
      // pick the first that has compatible cuisine
      var pairMate; 
      for(var i=0; i<matePool.length; i++){

          // if the from the mate pool is cuisine compatible and the next pool with both these has length > 0
          if( userCuisineCompatible( currUser, matePool[i] ) 
                && ( poolLengthOFF || regroup( matePool, pairMate, true ) ) ){
            pairMate = matePool.splice(i, 1); // removes pairmate at the same time                       
            break;
          }
      }

      // if no one is cuisine compatible, just pick best friend
      if(pairMate == undefined)
        var i=0;
        while(i < matePool.length){
          if(poolLengthOFF || regroup( matePool, pairMate, true )){
            pairMate = matePool.splice(i,1); // removes pairmate at the same time  
            break;
          }
          i++;               
        }
      }

      return pairMate;
    }

    // adds the required match
    function addMatch( participants ){

      // find a matching restaurant
      var restaurant = "";
      Restaurant.find({
          cuisine: { $in : user1.cuisine.concat(user2.cuisine) }
        }, function(err, res){
           if(err) console.log(err);

           else restaurant = res[0];
      })

      // create and add a match to the database
      Match.create({
        date: Date(),
        participants: participants,
        location: restaurant
      }, function(err, doc){
          if(err) console.log(err);

          else console.log("Match created", doc);
      })

    }

    // removes the users from the pool
    function removeFromPool( userPool, participants ){
      for(var i=0; i<participants.length; i++){
        var index = userPool.indexOf(participants[i]);
        userPool.splice(index, 1);
      }
    }    
}
